::: {.content-hidden}
Copyright (C) 2025 Harald Pretl and co-authors (harald.pretl@jku.at)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:::

# Phase-Locked Loops {#sec-pll}

Thinking about oscillators, we face a dilemma:

- Good phase noise performance is reached with high to very high $Q$ in the resonator (see @eq-leeson-equation).
- Oscillator tunability requires a tunable resonator, which usually results in a low-to-moderate $Q$, unfortunately.
- Oscillators have inherent frequency stability issues due to temperature variations, device aging, and supply voltage fluctuations. However, for wireless communication systems, precise frequency control and a very stable LO (down to a few ppm of accuracy) is required.

## Basic PLL Architecture {#sec-pll-basic-architecture}

We solve the issues above by using a **phase-locked loop (PLL)** to stabilize and control the frequency of a tunable oscillator, mostly in the form of a VCO. A PLL is a feedback control system that locks the phase of the VCO output to the phase of a reference signal, typically generated by a crystal oscillator with excellent frequency stability. The block diagram of a basic PLL is shown in @fig-pll-block-diagram.

{{< include /content/pll/_fig_pll_block_diagram.qmd >}}

A reference frequency (often coming from a high-$Q$ crystal oscillator) is compared to the phase of a VCO output signal in a phase detector (PD). The phase error is low-pass filtered and used to tune the VCO frequency. By continuously adjusting the VCO based on the phase difference, the PLL ensures that the VCO output remains synchronized with the reference signal, effectively combining the stability of the reference with the tunability of the VCO. When the output signal of the VCO is fed back to the phase detector through a frequency divider (with division ratio $N$), the PLL can generate output frequencies that are integer multiples of the reference frequency, given by $f_\mathrm{out} = N \cdot f_\mathrm{ref}$.

The PD compares the phase of the reference signal with the phase of the VCO output signal. It works in the time domain and produces an output voltage proportional to the arrival time difference (phase difference) between the two input signals. This output voltage, known as the phase error signal, indicates whether the VCO is leading or lagging the reference signal in phase, expressed as

$$
\Delta \varphi = 2 \pi \frac{\Delta t}{T_\mathrm{ref}}
$$

and

$$
V_\mathrm{error} = K_\mathrm{PD} \cdot \Delta \varphi
$$

where $\Delta \varphi$ is the phase difference (caused by the arrival time difference) in rad, $K_\mathrm{PD}$ is the phase detector gain in V/rad, $\Delta t$ is the time difference between the two signals, and $T_\mathrm{ref}$ is the period of the reference signal.

An important consideration of the PD is its linear operating range. The PD can only provide a linear output voltage for small phase differences, typically within ±180° (±π rad). If the phase difference exceeds this range, the PD characteristic "wraps around," leading to ambiguity in the phase error signal. This can cause the PLL to lose lock or behave unpredictably. Therefore, the PLL design must ensure that the phase difference remains within the linear range of the PD during normal operation, which is especially troublesome if the output frequency $f_\mathrm{out}$ is not yet close enough to its final steady-state value. Note that a simple PD can be implemented by using an XOR gate for digital signals or a mixer for analog signals.

{{< include /content/pll/_fig_pd_xor_diagram.qmd >}}

We can see in @fig-pd-xor-diagram that the output of the XOR PD is high when the two input signals differ and low when they are the same. The output duty cycle is proportional to the phase difference between the two input signals. Note that this PD has no notion of frequency, only phase! Still, it can be used to lock the frequency of the VCO to the reference frequency, as a constant phase difference implies equal frequencies; however, this works only if the initial frequency difference is small enough. Also, this XOR-based PD does not evaluate the edges of the input signals, only their logic states. Therefore, it is crucial that both input signals are square waves with a 50% duty cycle to ensure proper operation of the PD.

::: {.callout-note}
## JK Flip-Flop Phase Detector
Instead of an XOR gate, which requires 50% duty cycle input signals, an edge-triggered JK flip-flop can be used. While the overall behavior is similar, the JK flip-flop-based PD is insensitive to duty cycle variations of the input signals, as it only evaluates the rising edges of the reference and feedback signals [@Best_PLL].
:::

As the output signal of the PD contains high-frequency components (at least at twice the reference frequency), a low-pass filter (LPF) is used to smooth the phase error signal before it is applied to the VCO tuning input. The LPF also determines the dynamic response of the PLL, affecting its stability and transient behavior. A well-designed LPF ensures that the PLL can quickly respond to changes in the reference signal or disturbances while maintaining stability and minimizing overshoot or oscillations in the output frequency. Often, the LPF has voltage-mode inputs and outputs to connect to the PD and VCO, respectively.

Using a digital divider in the feedback path to only pass every $N$-th cycle of the VCO output to the PD allows the PLL to generate output frequencies that are integer multiples of the reference frequency. This is particularly useful in applications such as frequency synthesis, where a wide range of frequencies is required from a single stable reference source. By adjusting the division ratio $N \in \mathbb{N}$, the PLL can produce various output frequencies while maintaining phase lock with the reference signal. However, note that the frequency resolution of the output frequencies $\Delta f_\mathrm{out}$ is limited to integer multiples of the reference frequency!

Putting everything together into an $s$-domain block diagram, the PLL can be modeled as shown in @fig-pll-block-diagram-s-domain.

{{< include /content/pll/_fig_pll_block_diagram_s_domain.qmd >}}

For the loop filter transfer function $H(s)$ we assume a simple first-order low-pass filter with a cutoff frequency of $\omega_\mathrm{LP} = 1 / T_\mathrm{LP}$ given by

$$
H_\mathrm{LP}(s) = \frac{1}{1 + s T_\mathrm{LP}}.
$$

::: {.callout-important}
## Why Regulate Phase Instead of Frequency (PLL vs. FLL)?
Before we proceed, it is worth discussing why PLLs regulate the phase of the VCO output rather than its frequency directly. The reason lies in the relationship between phase and frequency: Frequency is the time derivative of phase. By controlling the phase, the PLL inherently controls the frequency as well. Additionally, even if the phase regulation has a steady-state phase error $\varphi_\mathrm{err}$, the frequency error in steady state is **zero**, as can be appreciated when inspecting

$$
\omega_\mathrm{out}(t) = \frac{d \varphi_\mathrm{out}(t)}{dt}  = \frac{d}{dt} \left[ N \cdot \varphi_\mathrm{ref}(t) + \varphi_\mathrm{err} \right] = N \cdot \frac{d \varphi_\mathrm{ref}(t)}{dt} = N \cdot \omega_\mathrm{ref}(t).
$$

In principle, one could also design a frequency-locked loop (FLL) that compares the frequencies of the reference and VCO output signals directly (by, e.g., using counters), however, this usually results in non-zero frequency error in steady state. Nevertheless, FLLs are often used in combination with PLLs to improve acquisition time and robustness, especially in scenarios with large initial frequency offsets.
:::

We now derive the closed-loop transfer function of the PLL from reference phase $\varphi_\mathrm{ref}(s)$ to output phase $\varphi_\mathrm{out}(s)$. First, we note that

$$
V_\mathrm{PD}(s) = K_\mathrm{PD} \left[ \varphi_\mathrm{ref}(s) - \frac{\varphi_\mathrm{out}(s)}{N} \right]
$$

and

$$
\varphi_\mathrm{out}(s) = \frac{K_\mathrm{VCO}}{s} \cdot H_\mathrm{LP}(s) \cdot V_\mathrm{PD}(s) = \frac{K_\mathrm{VCO}}{s} \cdot \frac{1}{1 + s T_\mathrm{LP}} \cdot K_\mathrm{PD} \left[ \varphi_\mathrm{ref}(s) - \frac{\varphi_\mathrm{out}(s)}{N} \right].
$$

Note that this equation has one integrator $1/s$ (which we can also see in @fig-pll-block-diagram-s-domain). We call PLLs with one integrator in the loop a **Type-I PLL**. We can now rearrange to find the closed-loop transfer function $H(s)$ as

$$
H(s) = \frac{\varphi_\mathrm{out}(s)}{\varphi_\mathrm{ref}(s)} = N \cdot \frac{K_\mathrm{VCO} \cdot K_\mathrm{PD} \cdot \omega_\mathrm{LP} / N}{s^2 + s \cdot \omega_\mathrm{LP} + K_\mathrm{VCO} \cdot K_\mathrm{PD} \cdot \omega_\mathrm{LP} / N}.
$$ {#eq-pll-transfer-function}

We can use all techniques known from control theory to analyze the stability and dynamic response of the PLL based on @eq-pll-transfer-function, however, we have to keep the following in mind:

- $H(s)$ is a small-signal model of the PLL around its locked operating point, only valid for small perturbations. Large-signal behavior, such as acquisition and lock range, are not captured by this model.
- A PLL is a sampled system, working at instances of $T_\mathrm{ref}$. $H(s)$ is a continuous-time approximation, which is valid only if the loop bandwidth is much smaller (typically $1/10$) than the reference frequency $f_\mathrm{ref}$. If this approximation is not valid, a discrete-time model of the PLL must be used, deriving the $z$-domain transfer function $H(z)$.

If we compare the canonical form of a second-order system given by

$$
H(s) = K \cdot \frac{\omega_\mathrm{n}^2}{s^2 + s \cdot 2 \zeta \omega_\mathrm{n} + \omega_\mathrm{n}^2},
$$

with @eq-pll-transfer-function, we can identify the natural frequency $\omega_n$ and the damping factor $\zeta$ of the PLL as

$$
\omega_\mathrm{n} = \sqrt{\frac{K_\mathrm{VCO} \cdot K_\mathrm{PD} \cdot \omega_\mathrm{LP}}{N}}
$$ {#eq-pd-pll-natural-frequency}

and

$$
\zeta = \frac{1}{2} \sqrt{\frac{\omega_\mathrm{LP} \cdot N}{K_\mathrm{VCO} \cdot K_\mathrm{PD}}}.
$$ {#eq-pd-pll-damping-factor}

This allows us to use standard control theory results to design the PLL parameters $K_\mathrm{PD}$, $K_\mathrm{VCO}$, $\omega_\mathrm{LP}$, and $N$ to achieve the desired dynamic response and stability margins. Note that $\omega_\mathrm{n}$ and $\zeta$ are not independent, as they both depend on the same set of PLL parameters! This seriously limits the design of the loop dynamics and means that we need a more complex loop filter $H_\mathrm{LP}(s)$ to achieve more freedom in selecting $\omega_\mathrm{n}$ and $\zeta$ independently. Often, we want to choose $\zeta = 1/\sqrt{2} \approx 0.707$ to achieve a Butterworth response for a good step response without overshoot.

The poles of a second-order system are given by

$$
p_{1,2} = -\omega_\mathrm{n} \left( \zeta \pm \sqrt{\zeta^2 - 1} \right)
$$

with $\zeta = 1/\sqrt{2}$ resulting in complex conjugate poles at

$$
p_{1,2} = -\frac{\omega_\mathrm{n}}{\sqrt{2}} \pm j \frac{\omega_\mathrm{n}}{\sqrt{2}}.
$$

To summarize: We can make a simple PLL using an XOR for a PD, use a first-order LPF, plus a feedback divider to get frequency multiplication of $f_\mathrm{out} = N \cdot f_\mathrm{ref}$. However, the control over the loop dynamics is very limited, and the locking procedure of the PLL is tricky, as the PD has a limited linear range of ±180°, requiring that the VCO frequency at the start of the locking procedure is already close enough to the desired output frequency. In addition, $N$ is an integer, limiting the frequency resolution of the output frequencies to integer multiples of the reference frequency.

The question is how to improve the PLL design to overcome these limitations? We will explore advanced PLL architectures and techniques in the following section.

## Charge-Pump PLL {#sec-pll-charge-pump}

The fundamental limitations of the simple PLL architecture presented in @sec-pll-basic-architecture can be addressed by using a more sophisticated phase detector known as a **phase-frequency detector (PFD)** in combination with a **charge pump (CP)** [@Gardner.1980]. This combination allows for better control over the loop dynamics and improved locking behavior.

In order to drive the CP, we envision a PFD with two digital outputs: An "up" signal that indicates when the VCO phase lags behind the reference phase, and a "down" signal that indicates when the VCO phase leads the reference phase [@Brown.1971]. The PFD compares both the phase and frequency of the reference and feedback signals, providing a more robust locking mechanism. The typical implementation of a PFD is shown in @fig-pfd-implementation.

{{< include /content/pll/_fig_pfd_implementation.qmd >}}

The PFD operates as follows:

- If the reference signal leads the feedback signal (its rising edge arrives first), the "UP" output is activated, causing the CP to source current into the integration capacitor, *increasing* the VCO tuning voltage and thus the VCO frequency.
- If the feedback signal leads the reference signal (its rising edge arrives first), the "DOWN" output is activated, causing the CP to sink current from the integration capacitor, *decreasing* the VCO tuning voltage and thus the VCO frequency.
- If both signals are aligned in phase and frequency, both outputs are only activated for a short time (the gate delays of the DFF and the AND), and the CP does not source or sink current; the integration capacitor in the loop filter holds its voltage, maintaining the VCO frequency.
- The rising edge that arrives last resets both outputs, ensuring that the CP only sources or sinks current for a duration proportional to the phase difference between the two signals.

In the following, we will look at four different cases of PFD operation to illustrate its behavior.

1. *Reference leads feedback*: The "UP" output is activated, and the CP sources current to the loop filter, increasing the VCO frequency.

{{< include /content/pll/_fig_pfd_diagram1.qmd >}}

2. *Feedback leads reference*: The "DOWN" output is activated, and the CP sinks current from the loop filter, decreasing the VCO frequency.

{{< include /content/pll/_fig_pfd_diagram2.qmd >}}

3. *Both signals aligned*: Both outputs are briefly activated, but the CP does not source or sink current, maintaining the VCO frequency.

{{< include /content/pll/_fig_pfd_diagram3.qmd >}}

4. *Large frequency difference*: The PFD continues to source or sink current until the phases align, allowing the PLL to acquire lock even with large initial frequency offsets.

{{< include /content/pll/_fig_pfd_diagram4.qmd >}}

Let us now investigate the circuit of the CP. The UP and DOWN signals from the PFD control two current sources/sinks connected to the loop filter capacitor, as shown in @fig-cp-implementation.

{{< include /content/pll/_fig_cp_circuit.qmd >}}

When the UP signal is high, the CP *sources* a constant current $I_\mathrm{CP}$ into the loop filter capacitor $C_\mathrm{int}$, increasing its voltage linearly over time according to the phase error. Conversely, when the DOWN signal is high, the CP *sinks* a constant current $I_\mathrm{CP}$ from the capacitor, decreasing its voltage linearly.

Note that the top and bottom current sources must be well matched to ensure symmetric operation of the CP and should have a wide operating range. The output impedance of the CP is ideally very high so that the charge pump current does not depend on the voltage across the loop filter capacitor. Further, the switches introduce charge injection and clock feedthrough, which can cause unwanted ripples on the loop filter voltage, leading to spurious signals in the PLL output. Careful design of the switches and layout techniques are necessary to minimize these effects.

The voltage change on the capacitor can be expressed as

$$
\Delta V_\mathrm{LF} = \frac{1}{C_\mathrm{LF}} \int_0^{t_\mathrm{on}} I_\mathrm{int} \cdot dt
$$ {#eq-cp-voltage-change}

where $t_\mathrm{on}$ is the duration for which the UP or DOWN signal is active, proportional to the phase difference between the reference and feedback signals.

Taking the Laplace transform of @eq-cp-voltage-change, we find the transfer function of the CP from the UP/DOWN control signals to the loop filter voltage as

$$
H_\mathrm{CP}(s) = \frac{I_\mathrm{CP}}{2 \pi} \left( \frac{1}{s C_\mathrm{int}} + R_\mathrm{int} \right)
$$ {#eq-cp-transfer-function}

where we have added a resistor $R_\mathrm{int}$ in series with the capacitor $C_\mathrm{int}$ to introduce a zero in the loop filter transfer function, clearly showing the zero introduced by the resistor $R_\mathrm{int}$ in series with the capacitor $C_\mathrm{int}$. The need for this zero will become apparent when we analyze the PLL loop dynamics next.

The resulting PLL using a PFD-CP combination is shown in @fig-pll-pfd-cp.

{{< include /content/pll/_fig_pfd_cp_pll.qmd >}}

Neglecting $C_3$ for now, we can derive the closed-loop transfer function of the PLL from reference phase $\varphi_\mathrm{ref}(s)$ to output phase $\varphi_\mathrm{out}(s)$ as

$$
H(s) = \frac{\varphi_\mathrm{out}(s)}{\varphi_\mathrm{ref}(s)} = N \cdot \frac{\frac{I_\mathrm{CP} K_\mathrm{VCO}}{2 \pi C_\mathrm{int} N} (1 + s C_\mathrm{int} R_\mathrm{int})}{s^2 + s \frac{I_\mathrm{CP} K_\mathrm{VCO} R_\mathrm{int}}{2 \pi N} + \frac{I_\mathrm{CP} K_\mathrm{VCO}}{2 \pi C_\mathrm{int} N}} = N \cdot \frac{s \cdot 2 \zeta \omega_\mathrm{n} + \omega_\mathrm{n}^2}{s^2 + s \cdot 2 \zeta \omega_\mathrm{n} + \omega_\mathrm{n}^2}
$$ {#eq-cp-pll-transfer-function}

with

$$
\omega_\mathrm{n} = \sqrt{\frac{I_\mathrm{CP} K_\mathrm{VCO}}{2 \pi C_\mathrm{int} N}}
$$ {#eq-cp-pll-natural-frequency}

and

$$
\zeta = \frac{R_\mathrm{int}}{2} \sqrt{\frac{I_\mathrm{CP} K_\mathrm{VCO} C_\mathrm{int}}{2 \pi N}}.
$$ {#eq-cp-pll-damping-factor}

Looking at @eq-cp-pll-natural-frequency and @eq-cp-pll-damping-factor, we can see that we now have one additional *independent* parameter ($R_\mathrm{int}$) to set the natural frequency $\omega_\mathrm{n}$ and the damping factor $\zeta$ of the PLL independently (compare this to @eq-pd-pll-natural-frequency and @eq-pd-pll-damping-factor). This allows us to design the loop dynamics more flexibly to achieve the desired performance.

With @eq-cp-pll-damping-factor, we can now appreciate the need for the resistor $R_\mathrm{int}$ in series with the capacitor $C_\mathrm{int}$ in the loop filter. Without this resistor, the damping factor $\zeta$ would be zero, leading to an undamped system with oscillatory behavior and poor transient response. The resistor introduces a zero in the loop filter transfer function, providing the necessary damping to stabilize the PLL and improve its dynamic response.

Looking at @fig-pll-pfd-cp and @eq-cp-transfer-function, we can also see that the PFD-CP introduces another integrator in the loop. This integrator, together with the integrator from the VCO, makes the PLL a **Type-II PLL**. A Type-II PLL can achieve zero steady-state phase error for step changes in the reference phase and zero steady-state frequency error for ramp changes in the reference frequency.

In conclusion:

- The PLL regulates the phase of a VCO to match the phase of a reference signal, using feedback control. Even with a steady-state phase error, the frequency error is zero (Type-I PLL). In a Type-II PLL, both phase and frequency errors are zero in steady state.
- The lowpass behavior of the loop filter determines the dynamic response and stability of the PLL.
- Further, the PLL transfer function from reference phase to output phase has the form of a lowpass, which passes the reference oscillator phase noise to the output inside the passband. The phase noise of the VCO is suppressed inside the loop bandwidth, as the PLL corrects for phase deviations.
- Outside the PLL loop bandwidth, the VCO phase noise dominates, as the PLL cannot correct for phase deviations fast enough.

This phase noise shaping behavior is illustrated in @fig-pll-phase-noise, which shows how the reference and VCO phase noise contributions combine to form the total PLL output phase noise.

{{< include /content/pll/_fig_pll_phase_noise.qmd >}}

Note that inside the PLL loop bandwidth the reference phase noise is multiplied by the division ratio $N$ in power, i.e., $20 \log_{10}(N)$ in dB, as the PLL output frequency is $N$ times the reference frequency. In @fig-pll-phase-noise, $N = 100$ and a reference phase noise of -140 dBc/Hz is used. Large values of $N$ can significantly increase the reference phase noise contribution at the PLL output, which is why low phase noise references are essential for high-performance PLLs.

## All-Digital PLL {#sec-pll-all-digital}

In the PLL implementations discussed so far, we have used analog components such as the VCO, loop filter, and charge pump. While these analog PLLs can achieve excellent performance, they also come with challenges such as component variability, temperature sensitivity, and integration complexity in modern digital processes. The question arises: Can we implement a PLL using only digital components to overcome these challenges? The answer is yes, leading to the concept of the **all-digital phase-locked loop (ADPLL)** [@Staszewski.2003], where a block diagram is shown in @fig-adpll-block-diagram.

{{< include /content/pll/_fig_adpll_block_diagram.qmd >}}

Conceptually, the ADPLL in @fig-adpll-block-diagram is similar to the analog PLL in @fig-pll-block-diagram, with the key difference being that all components are implemented digitally. The phase detector is replaced by a time-to-digital converter (TDC), which measures the time difference between the reference and feedback signal edges and converts it into a digital phase error word. The loop filter is implemented as a digital filter (FIR, IIR, or similar), processing the phase error word to generate a tuning word for the digitally controlled oscillator (DCO). The DCO generates the output frequency based on the tuning word, completing the feedback loop.

The advantages of the ADPLL are that it can be fully integrated in a digital nm CMOS process, benefiting from scalability, low power consumption, small chip area, and immunity to analog component variations. Additionally, the digital nature of the ADPLL allows for easy programmability and adaptability to different applications. However, the ADPLL also faces challenges such as quantization noise from the TDC and DCO, nonlinearity (DNL and INL) of TDC and DCO, as well as coupling of digital switching noise into the oscillator output signal.

### Time-to-Digital Converter {#sec-pll-tdc}

The TDC is a crucial component of the ADPLL, responsible for measuring the time difference between the reference and feedback signal edges and converting it into a digital phase error word. The TDC operates by sampling the time interval between two events (the rising edges of the reference and feedback signals) and quantizing this interval into discrete levels. TDCs can be implemented using various techniques. One popular method is using a digital delay line. An exemplary implementation is shown in @fig-pll-tdc.

{{< include /content/pll/_fig_pll_tdc.qmd >}}

In @fig-pll-tdc, the reference signal edge runs through a series of buffers (delay elements) connected in a delay line configuration. The feedback signal edge is used to sample the state of the delay line at the moment it arrives. The outputs of the DFFs represent the time difference between the reference and feedback signals, which can be encoded into a digital phase error word. The resolution of the TDC is determined by the delay between each stage in the delay line, with finer delays providing higher resolution. However, increasing the resolution also increases the complexity and power consumption of the TDC.

The phase noise of the TDC (at the output of the ADPLL) arising from this time measurement quantization can be modeled as

$$
\phn[f] = 10 \cdot \log \left[ \frac{(2 \pi)^2}{12 f_\mathrm{ref}} \cdot \left(  \frac{\Delta T_\mathrm{TDC}}{T_\mathrm{DCO}} \right)^2 \right]
$$

where $\Delta T_\mathrm{TDC}$ is the time resolution of the TDC, $T_\mathrm{DCO}$ is the period of the DCO output frequency, and $f_\mathrm{ref}$ is the reference frequency. This equation shows that improving the TDC resolution (reducing $\Delta T_\mathrm{TDC}$) and increasing the reference frequency can help reduce the phase noise contribution from the TDC.

::: {.callout-note}
## TDC Resolution Example
To get an idea of the performance requirements for the TDC, we assume a DCO output frequency of 2.4 GHz (e.g., for a Bluetooth application) and a reference frequency of 40 MHz. If we aim for a TDC phase noise contribution of -100 dBc/Hz at the DCO output, we can rearrange the above equation to find the required TDC time resolution:

$$
\Delta T_\mathrm{TDC} = T_\mathrm{DCO} \cdot \sqrt{\frac{12 f_\mathrm{ref} \cdot 10^{\phn[f]/10}}{(2 \pi)^2}} = \frac{1}{2.4 \times 10^9} \cdot \sqrt{\frac{12 \cdot 40 \times 10^6 \cdot 10^{-10}}{(2 \pi)^2}} \approx 15\,\text{ps}
$$

This number is challenging but achievable with modern TDC designs in nm CMOS.
:::

### Digitally Controlled Oscillator {#sec-pll-dco}

With the implementation of the TDC clarified in @sec-pll-tdc, we now turn our attention to the digitally controlled oscillator (DCO), which generates the output frequency of the ADPLL based on a digital tuning word. The DCO is a digital equivalent of the VCO used in analog PLLs, and its frequency is adjusted by changing the digital input value. Fundamentally, two possible implementations exist:

1. An analog-controlled oscillator (e.g., a VCO) is combined with a digital-to-analog converter (DAC) to convert the digital tuning word into an analog control voltage. This approach is shown in @fig-pll-dco-dac.

{{< include /content/pll/_fig_pll_dco_dac.qmd >}}

2. A digitally-controlled oscillator uses a large number of small varactors or switched capacitor banks to adjust the oscillation frequency directly based on the digital tuning word. An example implementation of a switched varactor is shown in @fig-dco-switched-varactor, or a switched capacitor like shown in @fig-switched-capacitor is used.

{{< include /content/pll/_fig_dco_switched_varactor.qmd >}}

It has to be noted that while an ADPLL seems conceptually simpler than an analog PLL, the design of high-performance TDCs and DCOs can be quite complex and requires careful consideration of quantization noise, linearity, and power consumption. Coupling effects between different circuit blocks can also introduce unwanted spurs and phase noise folding in the ADPLL output. Therefore, while ADPLLs offer many advantages, they also present unique design challenges that must be addressed to achieve adequate performance.

## Fractional-N PLL {#sec-pll-frac-n}

With the PLL architectures discussed so far, the output frequency resolution is limited to integer multiples of the reference frequency, i.e., $f_\mathrm{out} = N \cdot f_\mathrm{ref}$ with $N \in \mathbb{N}$. For a fine output frequency resolution, this requires a very low reference frequency. With the rule of thumb that the PLL loop bandwidth should be less than $f_\mathrm{ref}/10$ to ensure stable operation, a low reference frequency also limits the achievable loop bandwidth, which is detrimental to phase noise performance and settling time. Further, we have learned in @sec-pll-charge-pump that large values of $N$ increase the reference phase noise contribution at the PLL output by $20 \log_{10}(N)$ dB, making it challenging to achieve low phase noise performance with high frequency resolution.

How to break these fundamental limitations? The answer lies in the concept of the **fractional-N PLL**, which allows for non-integer frequency multiplication.

Assume we want to generate an output frequency of $f_\mathrm{out} = 2.45\,\text{GHz}$ from a reference frequency of $f_\mathrm{ref} = 40\,\text{MHz}$. This requires a frequency multiplication factor of $N = 61.25$, which is not an integer. To achieve this, the fractional-N PLL employs a feedback divider that can switch between two integer division ratios, $N_1$ and $N_2$, such that the average division ratio over time equals the desired fractional value (the averaging is performed by the lowpass loopfilter, providing the averaged tuning voltage to the VCO / the tuning word to the DCO). In this case, we can choose $N_1 = 61$ and $N_2 = 62$. By alternating between these two division ratios in a controlled manner, the PLL can effectively achieve an average division ratio of 61.25, allowing it to generate the desired output frequency of 2.45 GHz. The following sequence illustrates this concept over four reference cycles:

$$
N = N_1, N_1, N_1, N_2 \implies \text{Average } N = \frac{61 + 61 + 61 + 62}{4} = 61.25
$$

A simple sequence like the one above works, but would lead to significant spurs in the PLL output spectrum due to the periodic nature of the division ratio switching, especially when the fractionality is close to an integer, and thus the sequence is long. Consider the case of $N = 61.01$, where we would need to switch to $N_2 = 62$ only once every 100 cycles of $N_1 = 61$:

$$
N = \frac{99 \cdot 61 + 1 \cdot 62}{100} = 61.01
$$

This periodic switching introduces spurious tones in the PLL output spectrum at multiples of $f_\mathrm{ref}/100$, which can potentially pass through the loop filter and appear in the output spectrum, degrading the signal quality.

To minimize these spurs, more sophisticated techniques such as *delta-sigma modulation* are employed to *randomize* the switching sequence, spreading the quantization noise over a wider frequency range and reducing its impact on the PLL output. Additionally, the quantization noise introduced by the fractional division is *pushed to higher frequencies* where it can be more easily filtered out by the loop filter.

### Delta-Sigma Modulator {#sec-pll-delta-sigma}

For an in-depth understanding of delta-sigma modulation, we refer to [@Schreier_DSM]. Here, we briefly summarize the key concepts relevant to fractional-N PLLs. In a nutshell, a delta-sigma modulator (DSM) is a feedback system that shapes quantization noise to higher frequencies, allowing for high-resolution digital-to-analog conversion or frequency synthesis. The basic structure of a first-order DSM is shown in @fig-pll-dsm-first-order.

{{< include /content/pll/_fig_pll_dsm_first_order.qmd >}}

In @fig-pll-dsm-first-order, the input signal $X(s)$ is transferred to the output $Y(s)$ with the following transfer function (we set $Q = 0$):

$$
Y(s) = X(s) \cdot \frac{1}{1 + s T} = X(s) \cdot H_\mathrm{LP}(s)
$$

The quantization noise $Q(s)$ introduced by the quantizer is shaped by the feedback loop, resulting in the following output contribution:

$$
Y(s) = Q(s) \cdot \frac{s T}{1 + s T} = Q(s) \cdot H_\mathrm{HP}(s)
$$

We can see that the quantization noise is highpass filtered, pushing it to higher frequencies, where it can be more easily filtered out by a subsequent lowpass filter.

The digital implementation of a first-order DSM is straightforward and one possible form is shown in @fig-pll-dsm-digital-first-order. At the point of truncation from $N+2$ bits to 1 bit (the MSB) we imagine quantization noise $q[n]$ being added to the signal.

{{< include /content/pll/_fig_pll_dsm_digital_first_order.qmd >}}

Calculating the $z$-domain transfer functions from input $X(z)$ to the output $Y(z)$ (the signal transfer function, STF) and quantization noise $Q(z)$ to $Y(z)$ (the noise transfer function, NTF), we find

$$
\frac{Y(z)}{X(z)} = \text{STF}(z) = z^{-1} \implies \text{STF}(z) = z^{-1}
$$

and

$$
\frac{Y(z)}{Q(z)} = \text{NTF}(z) = (1 - z^{-1}) \implies \text{NTF} = 1 - z^{-1}.
$$

We see that the STF is a simple delay, while the NTF has a zero at DC, pushing the quantization noise to higher frequencies. Taking the Laplace transform of the NTF to find the frequency shaped PSD of the quantization noise, we find

$$
S_\mathrm{y}(f) = S_\mathrm{q}(f) |H(f)|^2 = S_\mathrm{q}(f) \cdot 2 \left| 1 - \cos(2 \pi f T_\mathrm{s}) \right| \implies H(f) = \sqrt{ 2 \left| 1 - \cos(2 \pi f T_\mathrm{s}) \right| }.
$$

with $T_\mathrm{s}$ being the sampling period of the DSM. The resulting $H(f)$ is shown in @fig-pll-dsm-ntf-plot. With the assumed PLL loop bandwidth of 100 kHz and a reference frequency of 40 MHz, we can see that the quantization noise is significantly attenuated inside the PLL loop bandwidth, minimizing its impact on the PLL output phase noise. The general trend is that higher-order DSMs and faster sampling frequencies lead to better noise shaping and lower in-band quantization noise.

{{< include /content/pll/_fig_pll_dsm_ntf_plot.qmd >}}

If we analyze the signal properties of the number sequence generated by the first-order DSM in @fig-pll-dsm-digital-first-order, we find that its randomization properties are not ideal, leading to spurs in the PLL output spectrum. To improve the randomization properties, higher-order DSMs are used in fractional-N PLLs, especially 2nd or 3rd order. A consequence of a higher-order DSM is that the produced sequence can take more values than just $N$ and $N+1$. The range of produced values is shown in @tbl-pll-dsm-orders.

| DSM Order | Output Range     | Noise Shaping |
|-----------|------------------|---------------|
| 1         | $N, N+1$         | 20 dB/decade  |
| 2         | $N-1 \ldots N+2$ | 40 dB/decade  |
| 3         | $N-3 \ldots N+4$ | 60 dB/decade  |
: DSM output ranges and characteristics for different orders {#tbl-pll-dsm-orders}

A standard 3rd-order DSM implementation has issues with stability due to the phase shift of three integrators in the feedback loop. To mitigate this, a well-known architecture called the **MASH (multi-stage noise shaping) DSM** is often used [@Matsuya.1989], which consists of multiple first-order DSM stages cascaded together. An example Python implementation of a 3rd-order MASH DSM is shown in @fig-mash-nodither, showing a snippet of the time-domain output and the resulting frequency spectrum, showing the noise shaping. As can be clearly seen, even using a 3rd-order MASH, there are strong spurious signals showing up in the spectrum. The time series shows that for some static input values (like here 0.125) patterns with short period can exist.

{{< embed ./content/pll/delta_sigma_modulator.ipynb#fig-mash-nodither >}}

As potential solution, we can add a very small dithering signal (i.e., adding a random signal to the input), which breaks these patterns. As shown in @fig-mash-dither, dithering indeed causes enough randomization so that the noise shaping can be clearly seen without noticable spurs (this is evident when comparing the time series of @fig-mash-nodither and @fig-mash-dither). Care has to be taken that the added random noise is small enough to not cause issues with inband noise.

{{< embed ./content/pll/delta_sigma_modulator.ipynb#fig-mash-dither >}}

A block diagram of a 3rd-order [MASH 1-1-1](http://www.aholme.co.uk/Frac2/Mash.htm) implementation including dither injection (shown in blue) is depicted in @fig-mash-third-order. The dither is typically implemented digitally as a pseudo-random bit sequence (PRBS) generator, often in the form of a [linear-feedback shift register](https://en.wikipedia.org/wiki/Linear-feedback_shift_register) (LFSR).

{{< include /content/pll/_fig_mash_third_order.qmd >}}

### Fractional-N PLL Implementation {#sec-pll-frac-n-implementation}

A block diagram of a fractional-N PLL using a DSM and a multi-modulus divider (MMD) is shown in @fig-pll-frac-n-block. In order to ease the timing loop of the jittered clock coming from the MMD, the DSM is typically clocked by the MMD's output.

{{< include /content/pll/_fig_pll_frac_n_block_diagram.qmd >}}

For a practical implementation of a fractional-N PLL it is of utmost importance that the path from the MMD output to the loop filter output is linear, as only the averaging/lowpass filtering of the noise-shaped quantization noise reduces the noise. Any *nonlinearity* in this path will lead to distortion of the quantization noise, causing quantization noise folding back into the PLL loop bandwidth, degrading the PLL output phase noise!

One prominent source of nonlinearity is the difference between the source and sink currents of the charge pump, as well as any nonlinearity present in the PFD/CP operating point of $\Delta \varphi \approx 0$ (like a deadzone). Since a Type-II PLL ideally operates at exactly this point, with random excursions around it due to the DSM-induced jitter, any nonlinearity here will seriously degrade the PLL performance. There are predominantly two options to mitigate this issue:

1. Use a Type-I PLL architecture with $\Delta \varphi \neq 0$.
2. Introduce a phase offset in a Type-II PLL to operate away from $\Delta \varphi = 0$.

A simple way to introduce a phase offset is to add a fixed current source/sink to the charge pump, as shown in @fig-pll-cp-offset.

{{< include /content/pll/_fig_cp_circuit_w_offset.qmd >}}

As we have seen multiple times in the PLL discussion, using a higher $f_\mathrm{ref}$ is beneficial for phase noise performance, loop bandwidth, and TDC resolution (in an ADPLL). However, in many applications the choice of reference frequency is constrained by other factors. One way to achieve a higher reference frequency is by using a **frequency doubler**. As shown in @fig-ref-doubler, a frequency doubler can be implemented using an XOR gate and a delay line. The delay line is set to a quarter of the period of the reference frequency, i.e., $T_\mathrm{d} = T_\mathrm{ref} / 4$. The XOR gate then produces an output frequency of $f_\mathrm{double} = 2 \cdot f_\mathrm{ref}$. For stable operation, this delay line must be designed to be relatively insensitive to process, voltage, and temperature (PVT) variations, or must be adjusted with a control loop.

{{< include /content/pll/_fig_ref_doubler.qmd >}}

As a final remark, we note that the output of the MMD in @fig-pll-frac-n-block is a jittered clock due to the changing division ratio and the multiple gates and flip-flops that make up the MMD. This jitter degrades the PLL phase noise performance. Fortunately, there is an easy fix for this issue by using a retiming flip-flop after the MMD, clocked by the oscillator output, as shown in @fig-pll-frac-n-block-retiming.

{{< include /content/pll/_fig_pll_frac_n_block_diagram_retiming.qmd >}}

This retiming flip-flop effectively synchronizes the MMD output to the oscillator clock domain, significantly reducing the jitter seen by the loop filter and improving the overall phase noise performance of the fractional-N PLL.
