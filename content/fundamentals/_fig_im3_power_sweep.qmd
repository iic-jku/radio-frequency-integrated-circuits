::: {.content-hidden}
Copyright (C) 2025 Harald Pretl and co-authors (harald.pretl@jku.at)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:::

```{python}
#| label: fig-im3-power-sweep
#| echo: false
#| fig-cap: "Two-tone IM3 test showing fundamental and IM3 product power vs. input power, with IP3 intercept point definition. Equal input power per tone is assumed."

import numpy as np
import matplotlib.pyplot as plt

# Define input power range per tone (in dBm)
Pin_dBm = np.linspace(-40, 20, 1000)
Pin_linear = 10**(Pin_dBm/10)  # Convert to linear scale (mW)

# Circuit parameters
G_dB = 20  # Small signal gain in dB
G_linear = 10**(G_dB/10)  # Linear gain
alpha1 = np.sqrt(G_linear)  # Linear coefficient
alpha3 = -0.1 * alpha1  # Third-order coefficient (smaller for realistic IM3)

# Calculate fundamental output power (per tone)
# For two-tone test: each fundamental experiences compression + cross-modulation
# Simplified model: Pout_fund ≈ G * Pin * (1 + 3/4 * alpha3/alpha1 * Pin_total)
# where Pin_total = 2 * Pin (two equal tones)
Pin_total_linear = 2 * Pin_linear
compression_factor = 1 + 0.75 * (alpha3/alpha1) * Pin_total_linear
Pout_fund_linear = G_linear * Pin_linear * compression_factor
Pout_fund_dBm = 10 * np.log10(np.abs(Pout_fund_linear))

# Calculate IM3 output power
# IM3 power is proportional to Pin^3 (third-order effect)
# Simplified: PIM3 ≈ (3/4 * alpha3)^2 * Pin1 * Pin2^2 / alpha1
IM3_coefficient = (0.75 * alpha3)**2 / alpha1
Pout_IM3_linear = np.abs(IM3_coefficient) * Pin_linear * Pin_linear**2
Pout_IM3_dBm = 10 * np.log10(Pout_IM3_linear + 1e-12)  # Add small value to avoid log(0)

# Ideal linear responses (extrapolated)
Pout_fund_ideal_dBm = Pin_dBm + G_dB
Pout_IM3_ideal_dBm = 3 * Pin_dBm + 10 * np.log10(np.abs(IM3_coefficient))

# Find IP3 (third-order intercept point)
# IP3 is where extrapolated fundamental and IM3 lines intersect
# This occurs when: Pin + G = 3*Pin + IM3_offset
# Solving: IP3_in = (G - IM3_offset) / 2
IM3_offset = 10 * np.log10(np.abs(IM3_coefficient))
IP3_in_dBm = (G_dB - IM3_offset) / 2
IP3_out_dBm = IP3_in_dBm + G_dB

# Create the plot
fig, ax = plt.subplots(1, 1)

# Plot fundamental tone
valid_fund = (Pout_fund_dBm > -100) & (Pin_dBm <= 5)  # Filter values and limit x-axis to 5 dBm
ax.plot(Pin_dBm[valid_fund], Pout_fund_dBm[valid_fund], 'b-', linewidth=2.5, 
        label='Fundamental (ω₁, ω₂)')

# Plot IM3 products
valid_IM3 = (Pout_IM3_dBm > -100) & (Pin_dBm <= 0)  # Filter IM3 values between -100 and -20 dBm
ax.plot(Pin_dBm[valid_IM3], Pout_IM3_dBm[valid_IM3], 'r-', linewidth=2.5, 
        label='IM3 (2ω₁-ω₂, 2ω₂-ω₁)')

# Plot ideal linear extrapolations
ax.plot(Pin_dBm, Pout_fund_ideal_dBm, 'b--', linewidth=2, alpha=0.7, 
        label='Fundamental (extrapolated)')
ax.plot(Pin_dBm, Pout_IM3_ideal_dBm, 'r--', linewidth=2, alpha=0.7, 
        label='IM3 (extrapolated)')

# Mark IP3 point
ax.plot(IP3_in_dBm, IP3_out_dBm, 'ko', markersize=8, markerfacecolor='black', 
        markeredgewidth=2, markeredgecolor='black')

# Add vertical and horizontal lines for IP3
ax.axvline(IP3_in_dBm, color='gray', linestyle=':', alpha=0.7, 
           label=f'IP3 = {IP3_in_dBm:.1f} dBm')
ax.axhline(IP3_out_dBm, color='gray', linestyle=':', alpha=0.7)

# Add slope annotations
ax.text(-30, -5, '1 dB/dB slope', color='blue', rotation=20, 
        bbox=dict(boxstyle="round,pad=0.2", facecolor='lightblue', alpha=0.7))
ax.text(-20, -63, '3 dB/dB slope', color='red', rotation=46, 
        bbox=dict(boxstyle="round,pad=0.2", facecolor='lightcoral', alpha=0.7))

# Formatting
ax.set_xlabel('Input Power per Tone (dBm)')
ax.set_ylabel('Output Power (dBm)')
ax.grid(True, alpha=0.3)
ax.legend(loc='lower right')

# Set axis limits for better visualization
ax.set_xlim(-40, 20)
ax.set_ylim(-80, 40)

plt.show()
```
