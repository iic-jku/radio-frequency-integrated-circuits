::: {.content-hidden}
Copyright (C) 2025 Harald Pretl and co-authors (harald.pretl@jku.at)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
:::

```{python}
#| label: fig-16qam-constellation
#| echo: false
#| fig-cap: "16-QAM constellation diagram with Gray code labeling of constellation points."

import numpy as np
import matplotlib.pyplot as plt

# Create figure and axis
fig, ax = plt.subplots(1, 1)

# Define 16-QAM constellation points
# Standard 16-QAM has points at ±1, ±3 for both I and Q
I_levels = [-3, -1, 1, 3]
Q_levels = [-3, -1, 1, 3]

# Gray code mapping for 16-QAM (4 bits per symbol)
# Convention: [b3, b2, b1, b0] where b3,b2 = Q bits, b1,b0 = I bits
gray_code_map = {
    (-3, -3): '0000',  # Q=-3, I=-3
    (-1, -3): '0001',  # Q=-1, I=-3
    (1, -3):  '0011',  # Q=1,  I=-3
    (3, -3):  '0010',  # Q=3,  I=-3
    (-3, -1): '0100',  # Q=-3, I=-1
    (-1, -1): '0101',  # Q=-1, I=-1
    (1, -1):  '0111',  # Q=1,  I=-1
    (3, -1):  '0110',  # Q=3,  I=-1
    (-3, 1):  '1100',  # Q=-3, I=1
    (-1, 1):  '1101',  # Q=-1, I=1
    (1, 1):   '1111',  # Q=1,  I=1
    (3, 1):   '1110',  # Q=3,  I=1
    (-3, 3):  '1000',  # Q=-3, I=3
    (-1, 3):  '1001',  # Q=-1, I=3
    (1, 3):   '1011',  # Q=1,  I=3
    (3, 3):   '1010',  # Q=3,  I=3
}

# Plot constellation points
for q_val in Q_levels:
    for i_val in I_levels:
        # Plot point
        ax.plot(i_val, q_val, 'ro', markerfacecolor='blue', 
                markeredgecolor='blue', markeredgewidth=2)
        
        # Add Gray code label
        gray_code = gray_code_map[(q_val, i_val)]
        ax.text(i_val + 0.1, q_val + 0.3, gray_code, color='blue')

# Add vector from origin to constellation point (3,3)
target_i, target_q = 3, 3
ax.annotate('', xy=(target_i, target_q), xytext=(0, 0),
            arrowprops=dict(arrowstyle='->', lw=2.5, color='red'))

# Calculate amplitude and phase for the vector
amplitude = np.sqrt(target_i**2 + target_q**2)
phase_rad = np.arctan2(target_q, target_i)
phase_deg = np.degrees(phase_rad)

# Add amplitude label along the vector (positioned to avoid overlap)
mid_i, mid_q = target_i/2, target_q/2
ax.text(mid_i + 1, mid_q + 0.5, r'$A_N$', color='red', ha='center', va='center')

# Draw phase arc from x-axis
arc_radius = 1.2
theta = np.linspace(0, phase_rad, 50)
arc_x = arc_radius * np.cos(theta)
arc_y = arc_radius * np.sin(theta)
ax.plot(arc_x, arc_y, 'g-', linewidth=2)

# Add phase label (positioned to avoid overlap with grid and other elements)
arc_label_radius = arc_radius + 0.2
arc_label_angle = phase_rad / 3
label_x = arc_label_radius * np.cos(arc_label_angle)
label_y = arc_label_radius * np.sin(arc_label_angle)
ax.text(label_x + 0.2, label_y + 0.2, r'$\varphi_N$', color='green', ha='center', va='center')

# Add second vector from origin to constellation point (-1,-3)
target_i2, target_q2 = -1, -3
ax.annotate('', xy=(target_i2, target_q2), xytext=(0, 0),
            arrowprops=dict(arrowstyle='->', lw=2.5, color='purple'))

# Calculate amplitude and phase for the second vector
amplitude2 = np.sqrt(target_i2**2 + target_q2**2)
phase_rad2 = np.arctan2(target_q2, target_i2)
phase_deg2 = np.degrees(phase_rad2)

# Add amplitude label along the second vector (positioned to avoid overlap)
mid_i2, mid_q2 = target_i2/2, target_q2/2
ax.text(mid_i2 - 0.8, mid_q2 - 0.3, r'$A_{N+1}$', color='purple', ha='center', va='center')

# Draw phase arc from x-axis for second vector (counterclockwise)
arc_radius2 = 1.0
# Calculate the positive angle for counterclockwise arc
# For point (-1,-3), we go counterclockwise from 0 to the angle
phase_rad2_positive = phase_rad2 + 2*np.pi if phase_rad2 < 0 else phase_rad2
theta2 = np.linspace(0, phase_rad2_positive, 100)
arc_x2 = arc_radius2 * np.cos(theta2)
arc_y2 = arc_radius2 * np.sin(theta2)
ax.plot(arc_x2, arc_y2, 'orange', linewidth=2)

# Add phase label for second vector (positioned in second quadrant to avoid overlap)
# Place label in the second quadrant where there's more space
label_x2 = -1.6
label_y2 = 0.5
ax.text(label_x2, label_y2, r'$\varphi_{N+1}$', color='orange', ha='center', va='center')

# Draw grid lines at constellation boundaries
for val in [-3, -1, 0, 1, 3]:
    ax.axvline(x=val, color='gray', linestyle='--', alpha=0.3)
    ax.axhline(y=val, color='gray', linestyle='--', alpha=0.5)

# Draw axes
ax.axhline(y=0, color='black', linewidth=1.5)
ax.axvline(x=0, color='black', linewidth=1.5)

# Add arrows to axes
ax.annotate('', xy=(5, 0), xytext=(-5, 0), 
            arrowprops=dict(arrowstyle='->', lw=2, color='black'))
ax.annotate('', xy=(0, 5), xytext=(0, -5), 
            arrowprops=dict(arrowstyle='->', lw=2, color='black'))

# Axis labels
ax.text(5.5, 0, 'I (In-phase)', ha='left')
ax.text(0, 5.52, 'Q (Quadrature)', ha='center')

# Set axis properties
ax.set_xlim(-5, 5)
ax.set_ylim(-5, 5)
ax.set_aspect('equal')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()
```
